<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>007 tutorial</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
    <style>
      .perl6-feature { background: #ddf; }
      .python-feature { background: #dfd; }
    </style>
  </head>
  <body>
<a href="https://github.com/masak/007"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/652c5b9acfaddf3a9c326fa6bde407b87f7be0f4/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6f72616e67655f6666373630302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png"></a>
<div class="container">
<h2 id="overview">Overview</h2>
<blockquote>
<p><strong>Q</strong>: Good to see you Mr Bond, things have been awfully dull around here...Now you're on this, I hope we're going to have some gratuitous sex and violence!<br><strong>James Bond</strong>: I certainly hope so too.</p>
</blockquote>
<p>007 is a small language. It has been designed with the purpose of exploring ASTs, macros, the compiler-runtime barrier, and program structure introspection.</p>
<p>In terms of language features, it's perhaps easiest to think of 007 as the secret love child of Perl 6 and Python.</p>
<table class="table table-bordered">
<tr>
  <th                      >feature</th>
  <th                      >Perl 6</th>
  <th                      >007</th>
  <th                      >Python</th>
</tr>
<tr>
  <td                      >braces</td>
  <td class="perl6-feature">yes</td>
  <td class="perl6-feature">yes</td>
  <td class="python-feature">no</td>
</tr>
<tr>
  <td                      >user-defined operators</td>
  <td class="perl6-feature">yes</td>
  <td class="perl6-feature">yes</td>
  <td class="python-feature">no</td>
</tr>
<tr>
  <td                      >variable declarations</td>
  <td class="perl6-feature">yes</td>
  <td class="perl6-feature">yes</td>
  <td class="python-feature">no</td>
</tr>
<tr>
  <td                      >macros</td>
  <td class="perl6-feature">yes</td>
  <td class="perl6-feature">yes</td>
  <td class="python-feature">no</td>
</tr>
<tr>
  <td                      >implicit typecasts</td>
  <td class="perl6-feature">yes</td>
  <td class="python-feature">no</td>
  <td class="python-feature">no</td>
</tr>
<tr>
  <td                      >sigils</td>
  <td class="perl6-feature">yes</td>
  <td class="python-feature">no</td>
  <td class="python-feature">no</td>
</tr>
<tr>
  <td                      >multis</td>
  <td class="perl6-feature">yes</td>
  <td class="python-feature">no</td>
  <td class="python-feature">no</td>
</tr>
<tr>
  <td                      >implicit returns</td>
  <td class="perl6-feature">yes</td>
  <td class="python-feature">no</td>
  <td class="python-feature">no</td>
</tr>
</table>
<h2 id="values">Values</h2>
<p>A small number of values in 007 can be expressed using literal syntax.</p>
<pre><code>123                 Q::Literal::Int
&quot;Bond.&quot;             Q::Literal::Str
[0, 0, 7]           Q::Literal::Array
None                Q::Literal::None</code></pre>
<p>Only double quotes are allowed. Strings don't have any form of interpolation.</p>
<p>The <code>None</code> value is a singleton. It's the value of unassigned variables and subroutines that don't <code>return</code> anything.</p>
<h2 id="expressions">Expressions</h2>
<blockquote>
<p><strong>James Bond</strong>: A gun and a radio. It's not exactly Christmas, is it?<br><strong>Q</strong>: Were you expecting an exploding pen? We don't really go in for that anymore.</p>
</blockquote>
<p>You can add integers together, and negate them.</p>
<pre><code>40 + 2              Q::Infix::Addition
-42                 Q::Prefix::Minus</code></pre>
<p>Strings can be concatenated.</p>
<pre><code>&quot;Bo&quot; ~ &quot;nd.&quot;        Q::Infix::Concat</code></pre>
<p>Arrays can be indexed. (Strings can't, but there's a builtin for that.)</p>
<pre><code>ar[3]               Q::Postfix::Index</code></pre>
<p>There's an assignment operator, and a comparison operator. These work on all types.</p>
<pre><code>name = &quot;Bond&quot;       Q::Infix::Assignment
42 == 40 + 2        Q::Infix::Eq</code></pre>
<p>There is no boolean type; comparison yields <code>1</code> and <code>0</code>. Comparison is strict, in the sense that <code>7</code> and <code>&quot;7&quot;</code> are not considered equal under <code>==</code>, and an array is never equal to an int, not even the length of the array.</p>
<p>The only thing that can be assigned to is variables. Arrays are immutable values, and you can't assign to <code>ar[3]</code>, for example.</p>
<pre><code>ar[3] = &quot;hammer&quot;;   # error; can&#39;t touch this</code></pre>
<p>Operands don't need to be simple values. Arbitrarily large expressions can be built. Parentheses can be used to explicitly show evaluation order.</p>
<pre><code>10 + -(2 + int(&quot;3&quot; ~ &quot;4&quot;))</code></pre>
<h2 id="variables">Variables</h2>
<p>In order to be able to read and write a variable, you must first declare it.</p>
<pre><code>my name;            Q::Statement::My</code></pre>
<p>As part of the declaration, you can also do an assignment.</p>
<pre><code>my name = &quot;Bond&quot;;</code></pre>
<p>Variables are only visible for the rest of the scope they are declared in. All scopes are delimited by braces, except for the scope delimiting the whole program.</p>
<pre><code>{
    my drink = &quot;Dry Martini&quot;;
    say(drink);     # works
}
say(drink);         # fails, no longer visible</code></pre>
<p>It's fine for a variable in an inner scope to have the same name as one in an outer scope. The inner variable will then &quot;shadow&quot; the outer until it's no longer visible.</p>
<pre><code>my x = 1;
{
    my x = 2;
    say(x);         # 2
}
say(x);             # 1</code></pre>
<h2 id="statements">Statements</h2>
<blockquote>
<p><strong>Q</strong>: It is to be handled with special care!<br><strong>Bond</strong>: Everything you give me...<br><strong>Q</strong>: ...is treated with equal contempt. Yes, I know.</p>
</blockquote>
<p>We've seen two types of statement already: variable declarations, and expression statements.</p>
<pre><code>my name = &quot;Bond&quot;;   Q::Statement::My
say(2 + 2);         Q::Statement::Expr</code></pre>
<p>Expression statements are generally used for their side effects, so they tend to either call some routine or assign to some variable. However, this is not a requirement, and an expression statement can contain any valid expression.</p>
<p>Besides these simple statements, there are also a few compound statements for conditionals and loops.</p>
<pre><code>if 2 + 2 == 4 {}    Q::Statement::If
for xs -&gt; x {}      Q::Statement::For
while agent {}      Q::Statement::While</code></pre>
<p>There is also an immediate block statement. Immediate blocks run unconditionally, as if they were an <code>if 1 {}</code> statement.</p>
<pre><code>{ say(&quot;hi&quot;) }       Q::Statement::Block</code></pre>
<h2 id="subroutines">Subroutines</h2>
<p>Subroutines are similar to blocks, but they are declared with a name and a (non-optional) parameter list.</p>
<pre><code>sub f(x) {}         Q::Statement::Sub</code></pre>
<p>When calling a subroutine, the number of arguments must equal the number of parameters.</p>
<p>The parentheses in the call are mandatory. There is no <code>g &quot;Mr. Bond&quot;;</code> listop form.</p>
<p>Subroutines can return values.</p>
<pre><code>return 42;          Q::Statement::Return</code></pre>
<p>A return statement finds the lexically surrounding subroutine, and returns from it. Blocks are transparent to this process; a <code>return</code> simply doesn't see blocks.</p>
<pre><code>sub outer() {
    my inner = {
        return 42;
    }
    inner();
    say(&quot;not printed&quot;);
}
say(outer());</code></pre>
<h2 id="begin-and-constants"><code>BEGIN</code> and constants</h2>
<p><code>BEGIN</code> blocks are blocks of code that run as soon as the parser has parsed the ending brace (<code>}</code>) of the block.</p>
<pre><code>BEGIN {}            Q::Statement::BEGIN</code></pre>
<p>There is no statement form of <code>BEGIN</code>: you must put in the braces.</p>
<p>There's also a <code>constant</code> declaration statement:</p>
<pre><code>constant pi = 3;    Q::Statement::Constant</code></pre>
<p>The right-hand side of the <code>constant</code> declaration is evaluated at parse time, making it functionally similar to using a BEGIN block to do the assignment:</p>
<pre><code>my pi;
BEGIN {
    pi = 3;
}</code></pre>
<p>Constants cannot be assigned to after their declaration. Because of this, the assignment in the <code>constant</code> declaration is mandatory.</p>
<h2 id="setting">Setting</h2>
<p>There's a scope outside the program scope, containing a utility subroutines. These should be fairly self-explanatory.</p>
<pre><code>say(any)
type(any)
str(any)
int(any)

abs(int)
min(a, b)
max(a, b)
chr(int)

ord(char)
chars(str)
uc(str)
lc(str)
trim(str)
split(str, sep)
index(str, substr)
charat(str, pos)
substr(str, pos, chars?)

elems(array)
reversed(array)
sorted(array)
join(array, sep)
filter(fn, array)
map(fn, array)</code></pre>
<p>There are also constructor methods for creating program elements.</p>
<pre><code>Q::Literal::Int(value)
Q::Literal::Str(value)
Q::Literal::Array(value)
Q::Identifier(str)
Q::StatementList(array)
Q::ParameterList(array)
Q::ArgumentList(array)
Q::Block(paramlist, stmtlist)
Q::Quasi(stmtlist)
Q::Trait(ident, expr)
Q::Prefix::Minus(expr)
Q::Infix::Addition(lhs, rhs)
Q::Infix::Concat(lhs, rhs)
Q::Infix::Assignment(lhs, rhs)
Q::Infix::Eq(lhs, rhs)
Q::Postfix::Call(lhs, args)
Q::Postfix::Index(lhs, rhs)
Q::Statement::My(ident, expr?)
Q::Statement::Constant(ident, expr)
Q::Statement::Expr(expr)
Q::Statement::If(expr, block)
Q::Statement::Block(block)
Q::Statement::Sub(ident, block)
Q::Statement::Macro(ident, block)
Q::Statement::Return(expr?)
Q::Statement::For(expr, block)
Q::Statement::While(expr, block)
Q::Statement::BEGIN(block)</code></pre>
<p>If you put an expression into a <code>Q::Statement::Expr</code> by passing it to its constructor, you can get it out of the resulting Q object by calling the destructor <code>expr(q)</code>. All the parameter names above are also represented as destructors in the setting.</p>
<h2 id="macros">Macros</h2>
<blockquote>
<p><strong>Q</strong>: Now, look...<br><strong>Bond</strong>: So where is this cutting edge stuff?<br><strong>Q</strong>: I'm trying to get to it!</p>
</blockquote>
<p>Macros are a form of routine, just like subs.</p>
<pre><code>macro m(q) {}       Q::Statement::Macro</code></pre>
<p>When a call to a macro is seen in the source code, the compiler will call the macro, and then install whatever code the macro said to return.</p>
<pre><code>macro greet() {
    return Q::Postfix::Call(
        Q::Identifier(&quot;say&quot;),
        Q::ArgumentList([Q::Literal::Str(&quot;Mr Bond!&quot;)]));
}

greet();    # prints &quot;Mr Bond!&quot; when run</code></pre>
<h2 id="quasis">Quasis</h2>
<blockquote>
<p><strong>Q</strong>: Right. Now pay attention, 007. I want you to take great care of this equipment. There are one or two rather special accessories...<br><strong>James Bond</strong>: Q, have I ever let you down?<br><strong>Q</strong>: Frequently.</p>
</blockquote>
<p>It's sometimes convenient to express code as Qtree constructors, like above, and sometimes convenient to express it as code. Quasis are for the latter case.</p>
<pre><code>macro greet() {
    return quasi {
        say(&quot;Mr Bond!&quot;);
    }
}

greet();</code></pre>
<p>Quasis can contain <em>unquotes</em>, where we momentarily jump back from code to Qtrees. Mixing code and Qtrees like that is the main point of quasis. For instance, instead of specifying the string directly as above, we can construct the Q node for it, and inject it:</p>
<pre><code>constant greeting_ast = Q::Literal::Str(&quot;Mr Bond!&quot;);

macro greet() {
    return quasi {
        say({{{greeting_ast}}});
    }
}

greet();</code></pre>
<p>Note the need for <code>constant</code> in the mainline, because the macro <code>greet</code> runs very early. If we moved <code>greeting_ast</code> into the macro body, we could use <code>my</code>.</p>
</div>
  </body>
</html>
